---
description: Ingestion Contract MCP Server
globs:
alwaysApply: true
---
# Project Overview

This is an MCP (Model Context Protocol) server that generates and manages data ingestion contracts. The server provides tools for:

- Analyzing data sources and generating source contracts
- Defining data destinations with validation rules
- Creating transformation contracts that map source to destination with enrichment rules

The project follows a clean, layered architecture with clear separation of concerns between core logic, MCP interface, and CLI.

# Project Structure

## Core Logic (`core/`)

The core business logic, independent of any interface.

### `models.py`
Defines Pydantic models for Source, Destination, and Transformation contracts.

### `contract_generator.py`
Orchestrates contract generation, delegating to specific source analyzers.

### `sources/`
Contains logic for analyzing different data sources:
- `database/`: Database introspection and analysis (split into `engine.py`, `introspection.py`, etc.)
- `csv.py`: CSV file analysis
- `json.py`: JSON/NDJSON file analysis
- `utils.py`: Shared utilities (encoding detection, type inference)

## MCP Interface (`mcp_server/`)

The MCP-specific interface layer.

### `server.py`
The MCP server entry point. Defines tools and routes calls.

### `handlers.py`
Handles MCP tool calls, orchestrating the core logic and formatting responses.

## CLI Interface (`cli/`)

The Command Line Interface layer.

### `main.py`
CLI entry point using Typer.

### `commands/`
CLI command implementations (source, destination, config, etc.).

## Testing (`tests/`)

Tests are organized to mirror the source structure:
- `tests/core/`: Unit tests for core logic and analyzers
- `tests/mcp/`: Integration tests for MCP server and handlers
- `tests/cli/`: Tests for CLI commands
- `conftest.py`: Shared fixtures

## Build & Dependency Management

- **`pyproject.toml`**: Defines project metadata, dependencies, and tool configuration
  - Uses Hatchling as the build backend
  - Configures Ruff (linting/formatting), mypy (type checking), and pytest
- **`Makefile`**: Provides common development commands
  - `make lint`: Run Ruff linter
  - `make format`: Format code with Ruff
  - `make mypy`: Run type checking
  - `make test`: Run test suite
  - `make check`: Run all checks (lint, format-check, mypy)
- **`uv.lock`**: Lockfile for reproducible dependency resolution

# Architecture Principles

## Stateless Server Design
- The server does not maintain state between calls
- All operations use absolute paths provided by the client

## Absolute Imports
- Always use absolute imports: `from core.models import SourceContract`
- Never use relative imports: `from .models import SourceContract`

## JSON Returns
- All contract tools return JSON strings (via Pydantic's `.model_dump_json(by_alias=True)`)
- Error responses are also structured JSON with "error" keys

## Type Safety with Pydantic
- All data structures are Pydantic models with full validation
- Runtime validation happens automatically on model construction
- Aliases allow Python-friendly names (e.g., `data_schema`) while serializing to standard names (e.g., `schema`)

## Three-Contract Architecture
1. **Source Contracts**: Describe data sources (auto-analyzed)
2. **Destination Contracts**: Define data targets
3. **Transformation Contracts**: Map source â†’ destination

# Development Workflow

1. Make changes to code
2. Run `make check` to verify linting, formatting, and types
3. Run `make test` to ensure all tests pass
4. Fix any issues before committing

# Important Conventions

- **Never use relative imports** - always use absolute imports
- **Always include type hints** - use Python 3.13+ native types (`list`, `dict`, etc.)
- **Return structured JSON** - all contract operations return JSON strings
- **Require absolute paths** - all file operations must use absolute paths
- **Use Pydantic for data** - all contracts and schemas are Pydantic models
- **Test everything** - maintain high test coverage
